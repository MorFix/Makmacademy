<md-content class="lesson" flex mk-background="background-900">
	
  <h1 id="kerberos">Kerberos</h1>
<p>Basically, Kerberos come down to just this:</p>
<pre><code>- a protocol for authentication
- uses tickets to authenticate
- avoids storing passwords locally or sending them over the internet
- involves a trusted 3rd-party
- built on symmetric-key cryptography
</code></pre>
<p>You have a ticket - your proof of identity encrypted with a secret key for the particular service
requested on your local machine (creation of a ticket is described below) so long as it&#39;s valid,
you can access the requested service that is within a Kerberos realm.</p>
<p>Rather than re-entering your user/password credentials, your ticket (cached on your system) is used to authenticate allowing for single sign-on.</p>
<p>Your ticket is refreshed when you sign on to your computer, or when you <code>kinit USER</code> within your terminal.</p>
<h3 id="kerberos-realm">Kerberos Realm</h3>
<p>Admins create realms - Kerberos realms - that will encompass all that is available to access.\
Granted, you may not have access to certain services or host machines that is defined within the policy.</p>
<p>Your machine, The Client, lives within this realm, as well as the service or host you want to request
and the Key Distribution Center, KDC.</p>
<p>When requesting access to a service or host, three interactions take place between you and:</p>
<ul>
<li>The Authentication server</li>
<li>The Ticket Granting Server</li>
<li><p>The service or host machine that you&#39;re wanting access to.</p>
<p>Other Important points:</p>
</li>
<li>With each interaction, you&#39;ll receive two messages.
Each message is one that you can decrypt, and one that you can not.</li>
<li>The service or machine you are requesting access to NEVER communicates directly with the KDC.</li>
<li>The KDC stores all of the secret keys for user machines and service in it&#39;s database.</li>
<li>Secret keys are passwords plus a salt that are hashed. For services or host machines,
there are no passwords. A key is actually generated by an admin during initial setup and memorized
on the service/host machine.</li>
<li>Again, these secret keys are all stored in the KDC database: recall the Kerberos&#39; reliance on
symmetric-key cryptography.</li>
<li>The KDC itself is encrypted with a master key to add a layer of difficulty from stealing
keys from the database.</li>
</ul>
<h2 id="you-and-the-authentication-server">You and the Authentication Server</h2>
<p>You want to access an HTTP service, but first you must introduce yourself to the
Authentication Server. Logging into your computer, or <code>kinit USERNAME</code>,
initiates that introduction via a plaintext request for a Ticket Granting Ticket (TGT).
the plaintext message contains:</p>
<pre><code>* Your name/ID
* the name of the requested service (in this case, service is the TGT Server)
* your network address (may be a list of IP addresses for multiple machines, or may be null
if wanting to use on any machine)
* requested lifetime for the validity of the TGT
</code></pre>
<p>And is sent to the Authentication Server.
The Authentication Server will check if you are in the KDC database.
This check is only to see if you exist, no credentials are checked.
If there are no errors, it will randomly generate a key called a Session Key for use between
you and the Ticket Granting Server (TGS),</p>
<p>The Authentication server will then send two messages back to you.
One message is the TGT that contains:</p>
<pre><code>* Your name / ID
* The TGS name/ID,
* Timestamp
* Your network address
* lifetime of the TGT (could be what you initially requested,
lower if you or the TGS&#39;s secret keys are about to expire or another limit
that was implemented during the Kerberos setup)
* TGS Session key
</code></pre>
<p>And is encrypted with the TGS Secret Key. the other message contains:</p>
<pre><code>* The TGS name/id
* timestamp
* TGS Session Key
</code></pre>
<p>And is encrypted with your client Secret Key.
Note that the TGS Session key is the shared key between you and the TGS.</p>
<p>Your client Secret Key is determined by prompting you for your password,
appending a salt (made up of user@REALM_NAME.COM) and hashing the whole thing.
Niw you can use it for decrypting the second message in order to obtain the TGS Session Key.
If the password is incorrect, then you will not be able to decrypt the message.
You can not, however, decrypt the TGT since you do not know the TGS Secret Key.
The encrypted TGT is stored within your credential cache.</p>
<h2 id="you-and-the-ticket-granting-server">You and the Ticket Granting Server</h2>
<p>At this point, you have the TGT that you can not read because you do not have the TGS Secret Key
to decrypt it. You do, however, have the TGS Session Key.
It&#39;s now your turn to send two messages.
You first prepare the Authenticator, encrypted with the TGS Session Key, containing:</p>
<pre><code>* Your name / ID
* timestamp
</code></pre>
<p> You send an unencrypted message that contains:</p>
<pre><code>* the requested HTTP Service name / ID you want to access
* lifetime of the Ticket for the HTTP Service.
</code></pre>
<p>Along with the encrypted Authenticator and TGT to the Ticket Granting Server.</p>
<p>The Ticket Granting Server will first check the KDC database to see if the HTTP service exists
If so, the TGS decrypted the TGT with it&#39;s secret key.
Since the now unencrypted TGT contains the TGS Session Key, the TGS can decrypt the Authenticator you sent.
The TGS will then do the following:</p>
<pre><code>* Compare your client ID from the Authenticator to that of the TGT
* compare the timestamp from the Authenticator to that of the TGT
* check to see if the TGT is expired
* check that the Authenticator is not already in the TGS&#39;s cache ( for avoiding replay attacks )
* if the network address in the original request is not null,
 compares the source&#39;s IP address to your network address within the TGT.
</code></pre>
<p>The Ticket Granting Server then randomly generates the HTTP Service Session Key,
and prepares the HTTP Service ticket for you that contains:</p>
<pre><code>* Your name / ID
* HTTP Service Name / ID
* your network addresses
* timestamp
* lifetime of the validity of the ticket
* HTTP Service Session Key
</code></pre>
<p>And encrypts it with the HTTP Service Secret Key,
Then the TGS sends you two messages. One is the encrypted HTTP Service Ticket; the other contains:</p>
<pre><code>* HTTP Service name / ID
* timestamp
* lifetime of the validity of the ticket
* HTTP Service Session Key
</code></pre>
<p>That is encrypted with the TGS Session Key.
Your machine decrypted the latter message with the TGS Session Key
that it cached earlier to obtain the HTTP Service Session Key.</p>
<p>Your machine can not however decrypt the HTTP Service Ticket since it&#39;s encrypted
with the HTTP Service Secret Key.</p>
<h2 id="you-and-the-http-service">You and the HTTP Service</h2>
<p>To now access the HTTP Service, your machine prepares another Authenticator message that contains:</p>
<pre><code>* Your name / ID
* timestamp
</code></pre>
<p>And is encrypted with the HTTP Service Session Key.
Your machine then sends the Authenticator and the still-encrypted HTTP Service Ticket received from the TGS.
The HTTP Service then decrypts the Ticket with it&#39;s secret key to obtain the
HTTP Service Session Key. It then uses that Session Key to decrypt the Authenticator message you sent.
Similar to the TGS, the HTTP Server will now do the following:</p>
<pre><code>* Compare your client ID from the Authenticator to that of the Ticket
* compare the timestamp from the Authenticator to that of the Ticket
* check to see if the Ticket is expired
* check that the Authenticator is not already in the Http server&#39;s cache
* if the network adderss in the original request is not null,
compares the source&#39;s IP address to your network address within the Ticket
</code></pre>
<p>The HTTP service then sends an authenticator message containing its ID and timestamp
in order to confirm its identity to you and is encrypted with the HTTP Service Session Key.
Your machine reads the Authenticator message by decrypting with the cached HTTP Service Session Key,
and knows that it has to receive a message with the HTTP Service&#39;s ID and timestamp.
And now you have been authenticated to use the HTTP Service.
Future requests use the cached HTTP Service Ticket,
so long as it has not expired as defined within the lifetime attribute.</p>
<h2 id="read-about">Read About</h2>
<ul>
<li>keytab files</li>
<li>kadmin</li>
<li>deployment on linux servers</li>
<li>add users</li>
<li>GSSAPI</li>
<li>SPNEGO</li>
</ul>

  
</md-content>
